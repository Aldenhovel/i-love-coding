# C++

[TOC]



## basic

### 1 `struct` 和 `class` 关键字的区别？

1.  `class` 支持继承和多态， `struct` 不支持。

2.  `class ` 默认成员 `private` ， `struct`  默认为 `public` (但是也是可以设置为 `private` 的)：

   ```cpp
   struct Person {
   private:
       std::string name;
       int age;
   public:
       void SetName(std::string name) {
           this->name = name;
       }
       
       void SetAge(int age) {
           this->age = age;
       }
   };
   ```

### 2 `extern "C"` 是什么？

1. 在使用 C++ 与 C 代码交互时，需要使用 `extern "C"` 来告诉编译器使用 C 语言的命名和调用约定，以便正确链接和调用 C 代码中的函数。

2. C++ 与 C 语言的命名和调用约定是不同的，这主要是因为 C++ 支持函数重载和类成员函数等特性。在 C++ 中，编译器会根据函数的参数列表和返回值类型来生成不同的函数名称，以便实现函数重载。而在 C 语言中，函数名是唯一的标识符，不支持函数重载。

   因此，在使用 C++ 编写与 C 代码交互的程序时，需要使用 `extern "C"` 来告诉编译器使用 C 语言的命名和调用约定，以便正确链接和调用 C 语言的函数。

3. 例如，下面的示例演示了如何在 C++ 中使用 `extern "C"` 声明一个 C 函数：

   ```cpp
   #ifdef __cplusplus
   extern "C" {
   #endif
   
   void my_c_function();
   
   #ifdef __cplusplus
   }
   #endif
   
   ```

### 3 函数重载和覆盖的区别？

1. **函数重载（Function Overloading）**

   是指在同一个作用域中定义多个函数，它们具有相同的函数名，但是参数列表不同或者参数类型不同，或者参数顺序不同，或者返回类型不同。编译器会根据函数名、参数列表和返回类型等信息来决定使用哪个函数。函数重载可以提高代码的可读性和可维护性，使程序更加灵活。

2. **函数覆盖（Function Overriding）**

   是指派生类中的函数覆盖基类中的虚函数。在基类中，虚函数是用 virtual 关键字声明的成员函数，它允许派生类重写它的实现。在派生类中，如果函数的名称、参数列表和返回类型与基类中的虚函数相同，那么它就覆盖了基类中的虚函数。当通过基类指针或引用调用虚函数时，实际调用的是派生类中覆盖的函数。

3. 总的来说，函数重载是指在同一作用域中定义多个名称相同但参数列表不同的函数，可以用于增加代码的灵活性和可读性；函数覆盖是指在派生类中覆盖基类中的虚函数，用于实现多态性和继承。

### 4 多态是什么，运行时的实现原理是什么？

1. 多态允许同一种操作在不同的对象上有不同的行为。在 C++ 中，多态性通过虚函数来实现，称为虚函数多态性。

2. 在 C++ 中，虚函数的实现原理涉及到虚函数表和虚函数指针。每个对象的内存中会有一个指向虚函数表的指针，虚函数表是一个数组，其中存储了该类及其父类中所有的虚函数地址。当派生类中覆盖基类中的虚函数时，编译器会在派生类的虚函数表中修改对应函数的地址，使其指向派生类的函数实现。这样，在调用虚函数时，会根据对象的实际类型找到该类型对应的虚函数表，并调用其中的函数。

   虚函数的实现原理实现了动态绑定，使得程序在运行时可以根据实际对象的类型来确定调用的函数，从而实现了多态性。

### 5 单继承、多继承、虚继承是什么？

1. **单继承：**

   指派生类只从一个基类继承。单继承的继承方式是最常见的继承方式，它使得代码的组织更加清晰，易于维护和扩展。

2. **多继承：**

   指派生类从多个基类继承。多继承的优点是可以让一个类拥有多个基类的特性，从而实现更加灵活和高效的代码复用，但是也容易引起继承层次复杂和二义性的问题。

3. **虚继承：**

   虚继承是为了解决多继承带来的二义性问题而引入的，它将多个基类继承方式改为虚继承，使得派生类中只包含一个基类子对象。虚继承将多个基类的共同基类放到最顶层，避免了多个基类中拥有相同基类的情况，从而解决了二义性问题。

4. 虚继承的实现原理是在派生类的内存布局中添加一个虚基类指针，该指针指向共同基类的子对象。虚继承也会引入一些性能开销和复杂性，因此应该尽量避免过度使用。

   总之，单继承是最简单、最常用的继承方式，多继承可以实现更加灵活和高效的代码复用，但需要避免二义性问题，而虚继承则是为了解决多继承的二义性问题而引入的。

### 6 为什么不把所有函数都弄成虚函数

1. 虚函数虽然可以实现多态性，但是也会引入一些性能开销和复杂性。每个对象都需要保存一个指向虚函数表的指针，虚函数表本身也需要占用一定的**内存空间**。在多继承和虚继承的情况下，由于可能存在多个虚函数表，这些开销和复杂性还会进一步增加。
2. 此外，不是所有的函数都需要成为虚函数。只有在需要使用多态性的情况下，才需要将函数定义为虚函数。在其他情况下，非虚函数的**调用效率**要高于虚函数，因为非虚函数的调用是静态绑定的，可以在编译期确定调用的函数。

### 7 构造函数、析构函数可以是虚函数吗？

1. **构造函数不能是虚函数**

   因为虚函数是在对象被创建后才能使用的，而构造函数则是用来创建对象的，它们是互相矛盾的。

2. **析构函数可以是虚函数**

   通常当我们使用多态性的时候，需要将基类的析构函数定义为虚函数，这样在删除派生类对象时，会调用正确的析构函数，以避免内存泄漏等问题。

   ```cpp
   class Base {
   public:
       virtual ~Base() {}
   };
   
   class Derived : public Base {
   public:
       ~Derived() {}
   };
   
   int main() {
       Base* ptr = new Derived;
       delete ptr; // 调用正确的析构函数，避免内存泄漏
       return 0;
   }
   
   ```

   在这个例子中 `Base` 的析构函数为虚函数，派生类 `Derived` 的析构函数不需要定义为虚函数，因为它会自动继承基类的虚函数特性。我们通过基类指针 `ptr` 删除派生类对象，由于基类的析构函数是虚函数，所以会调用正确的析构函数，避免了内存泄漏等问题。

### 8 什么是纯虚函数，有什么用？

1. 纯虚函数是在基类中声明但没有定义实现的虚函数。它的语法形式为在函数声明的末尾加上 "= 0"，例如：

   ```cpp
   class Shape {
   public:
       virtual double getArea() const = 0;
   };
   
   ```

   在这个例子中，`getArea()` 函数被声明为纯虚函数，因为在基类中无法给出一个通用的实现，而只能由派生类来实现。一个类如果包含了一个或多个纯虚函数，就被称为**抽象类**。

2. 纯虚函数的作用在于，通过基类中的虚函数接口，**强制要求派生类来实现这些函数**。这种设计思想称为接口隔离原则，它可以确保派生类实现了基类中所定义的接口，从而保证了程序的正确性和可维护性。同时，纯虚函数还可以作为占位符使用，以便在派生类中给出一个具体的实现。

   需要注意的是，**包含纯虚函数的类不能被实例化**，而只能被作为基类来使用。如果派生类没有给出纯虚函数的具体实现，那么它也将成为一个抽象类，无法被实例化。

3. **使用场景**

   - 基类定义了一些函数接口，但是这些函数的具体实现方式取决于派生类，基类不能提供通用的实现方式。

   - 基类是一个抽象概念，不能直接被实例化，只能被用作派生类的基类。

   - 基类希望强制要求派生类必须实现某些函数。

### 9 什么是 RAII？

1. RAII是一种编程技术，全称为“资源获取即初始化”（Resource Acquisition Is Initialization）。它的核心思想是，资源的申请和释放应该在对象的构造和析构过程中自动完成，而不是依赖于程序员手动管理。RAII 通常用于管理资源的类，如文件句柄、内存、互斥锁等，可以保证这些资源在使用完毕后能够正确地被释放，从而避免资源泄露和内存泄露等问题。
2. 在 RAII 中，资源的申请通常在对象的**构造函数**中进行，而资源的释放则在对象的**析构函数**中完成。这样，在对象生命周期结束时，资源就会被自动释放。

### 10 类的大小如何计算

1. 类的大小由类的成员变量和成员函数共同决定。

2. **类成员大小**

   类的成员变量的大小是各个成员变量大小之和，其中需要考虑成员变量的对齐规则。在一些系统中，由于硬件原因，访问未对齐的数据会导致性能下降或者系统崩溃等问题，因此编译器会对成员变量进行对齐操作。对齐规则会根据编译器和平台的不同而有所区别，通常是按照成员变量的类型和当前编译环境的字节对齐要求来确定的。

3. **类函数大小**

   类的成员函数不占用类对象的空间，因为它们是代码段的一部分，每个对象共享同一个函数实现。但是，如果类的成员函数是虚函数，那么会为每个对象增加一个指向虚函数表的指针，这个指针的大小和指针的字节长度有关，通常为 4 或 8 字节。

4. 除了成员变量和成员函数外，类的大小还可能受到编译器和平台的其他限制，如内存对齐、编译器的优化策略等因素的影响。因此，在不同的编译器和平台上，同一个类的大小可能会不同。

5. 使用 C++ 中的 `sizeof` 运算符来计算类的大小。

### 11 `volatile` 关键字有什么用？

